<!-- demo-merged.html (pegar dentro de tu page) -->
<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ITB TRON — Merged Hero + Scroll Cinematic</title>

<link rel="stylesheet" href="https://2025.intothebox.org/modules_app/contentbox-custom/_themes/itb2025/includes/css/app.css">
  <link rel="alternate" type="application/rss+xml" title="Recent Blog Updates" href="https://2025.intothebox.org/blog/rss" />
<link rel="alternate" type="application/rss+xml" title="Recent Blog Comment Updates" href="https://2025.intothebox.org/blog/rss/comments" />
<link rel="alternate" type="application/rss+xml" title="Recent Page Updates" href="https://2025.intothebox.org/__rss/pages" />
<link rel="alternate" type="application/rss+xml" title="Recent Page Comment Updates" href="https://2025.intothebox.org/__rss/pages/comments" />
<link rel="alternate" type="application/rss+xml" title="Recent Content Updates" href="https://2025.intothebox.org/__rss" />
<link rel="alternate" type="application/rss+xml" title="Recent Content Comment Updates" href="https://2025.intothebox.org/__rss/comments" />
<link href="https://2025.intothebox.org/modules_app/contentbox-custom/_themes/itb2025/includes/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
<link href="https://2025.intothebox.org/modules_app/contentbox-custom/_themes/itb2025/includes/css/app.css" rel="stylesheet" type="text/css" />
<link href="https://2025.intothebox.org/modules_app/contentbox-custom/_themes/itb2025/includes/css/blog.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="/includes/images/favicon.ico" type="image/x-icon">
<link rel="icon" href="/includes/images/favicon.ico" type="image/x-icon">
<script type="f1e8b25ff7633980e57f4899-text/javascript" src="https://2025.intothebox.org/modules_app/contentbox-custom/_themes/itb2025/includes/js/bootstrap.bundle.min.js"></script>
<script defer type="f1e8b25ff7633980e57f4899-text/javascript" src="https://2025.intothebox.org/modules_app/contentbox-custom/_themes/itb2025/includes/js/app.js"></script>
<script type="f1e8b25ff7633980e57f4899-text/javascript" src="https://2025.intothebox.org/modules_app/contentbox-custom/_themes/itb2025/includes/js/axios.min.js"></script>


<style>
  :root{--bg:#0f1316}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter, system-ui, Arial;}
  /* canvas fullscreen */
  #three-canvas { position:fixed; inset:0; width:100%; height:100%; display:block; z-index:0; pointer-events:none; }
  /* content on top */
  main{position:relative;
     /* z-index:2; padding:10vh 6vw; max-width:1200px; margin:0 auto; */
    }
  h1{font-size:3.2rem; color:#C6FF4D; margin:0;}
  p.lead{color:#cfcfcf;margin-top:16px;line-height:1.6}
  /* page long enough to scroll */
  .spacer{ height: 4000px; }
</style>
</head>
<body>

<canvas id="three-canvas"></canvas>

<main>
  <div style="height:9000px"></div>
</main>

<script type="module">
/* Use esm.sh imports (los que funcionaron contigo) */
import * as THREE from "https://esm.sh/three@0.158.0";
import { EffectComposer } from "https://esm.sh/three@0.158.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://esm.sh/three@0.158.0/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "https://esm.sh/three@0.158.0/examples/jsm/postprocessing/UnrealBloomPass.js";

/* -----------------------
   Renderer / Scene / Cam
   ----------------------- */
const canvas = document.getElementById('three-canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
renderer.setPixelRatio(Math.max(1, window.devicePixelRatio || 1));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0f1316);

const camera = new THREE.PerspectiveCamera(1000, innerWidth / innerHeight, 0.8, 10000);
scene.add(camera);

/* composer + bloom */
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.9, 0.55, 0.12);
composer.addPass(bloom);

/* -----------------------
   Room builder (grid cube)
   ----------------------- */
function buildGridRoom(size = 1400, divisions = 22) {
  const group = new THREE.Group();

  function addGrid(origin, u, v, colorHex, opacity = 0.9) {
    const step = size / divisions;
    const verts = [];
    for (let i = 0; i <= divisions; i++) {
      const uval = -size/2 + i*step;
      const A = origin.clone().addScaledVector(u, uval).addScaledVector(v, -size/2);
      const B = origin.clone().addScaledVector(u, uval).addScaledVector(v,  size/2);
      verts.push(A.x,A.y,A.z, B.x,B.y,B.z);
    }
    for (let j = 0; j <= divisions; j++) {
      const vval = -size/2 + j*step;
      const A = origin.clone().addScaledVector(u, -size/2).addScaledVector(v, vval);
      const B = origin.clone().addScaledVector(u,  size/2).addScaledVector(v, vval);
      verts.push(A.x,A.y,A.z, B.x,B.y,B.z);
    }
    const g = new THREE.BufferGeometry();
    g.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
    const mat = new THREE.LineBasicMaterial({ color: colorHex, transparent: true, opacity: opacity, toneMapped: false });
    const lines = new THREE.LineSegments(g, mat);
    group.add(lines);
  }

  addGrid(new THREE.Vector3(0,0,size/2),  new THREE.Vector3(1,0,0), new THREE.Vector3(0,-1,0), 0x7CFF5A); // front
  addGrid(new THREE.Vector3(0,0,-size/2), new THREE.Vector3(-1,0,0), new THREE.Vector3(0,-1,0), 0x47F0C8, 0.72); // back (darker)
  addGrid(new THREE.Vector3(-size/2,0,0), new THREE.Vector3(0,0,1),  new THREE.Vector3(0,-1,0), 0x47F0C8);
  addGrid(new THREE.Vector3(size/2,0,0),  new THREE.Vector3(0,0,-1), new THREE.Vector3(0,-1,0), 0x7CFF5A);
  addGrid(new THREE.Vector3(0,-size/2,0), new THREE.Vector3(1,0,0),  new THREE.Vector3(0,0,1),  0x47F0C8);
  addGrid(new THREE.Vector3(0,size/2,0),  new THREE.Vector3(1,0,0),  new THREE.Vector3(0,0,-1), 0x7CFF5A);

  return group;
}
const room = buildGridRoom(1400, 22);
room.rotation.set(0.25, 0.8, 0);
scene.add(room);

/* -----------------------
   (removed glow sphere) -- you said it shouldn't be there
   ----------------------- */

/* -----------------------
   Camera framing / states (script1 hero + script2 cine)
   ----------------------- */
const track = {
  start: new THREE.Vector3(700, 180, 980), // <-- match your hero camera start
  mid:   new THREE.Vector3(700, 180, 980), // will be overwritten on first scroll (safe)
  end:   new THREE.Vector3(0, 40, 520)     // cinematic target
};

/* start in hero */
camera.position.copy(track.start);
camera.lookAt(new THREE.Vector3(1000, -20, 0)); // hero look (keeps same composition)

/* interpolation state */
const state = { t: 0 };

/* firstScroll guard to capture dynamic start */
let firstScroll = true;

/* -----------------------
   Scroll mapping (map whole page scroll to 0..1)
   ----------------------- */
let docH = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
function updateDocHeight(){ docH = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight); }
window.addEventListener('load', updateDocHeight);
window.addEventListener('resize', () => { updateDocHeight(); renderer.setSize(innerWidth, innerHeight); camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); composer.setSize(innerWidth, innerHeight); bloom.setSize(innerWidth, innerHeight); });

window.addEventListener('scroll', () => {
  const scrollY = window.scrollY || window.pageYOffset;
  const maxScroll = Math.max(1, docH - innerHeight);

  // On first scroll -> capture dynamic start & mid to avoid jump
  if (firstScroll && scrollY > 2) {
    firstScroll = false;
    // copy current camera position as the real start
    track.start.copy(camera.position);
    // set mid to be slightly toward cinematic but start from current to avoid abrupt curve.
    // mid will be used in sampleTrack (we emulate your sampleTrack with start-mid-end)
    track.mid.copy(camera.position);
  }

  // map entire scroll to 0..1 (you wanted full scroll drive)
  state.t = Math.min(1, Math.max(0, scrollY / maxScroll));
});

/* easing */
function smoothstep(x){ return x*x*(3 - 2*x); }

/* sample track similar to your sampleTrack function */
function sampleTrack(t) {
  // t in 0..1, we do start -> mid for first half, mid -> end for second
  if (t < 0.5) return new THREE.Vector3().lerpVectors(track.start, track.mid, smoothstep(t*2));
  return new THREE.Vector3().lerpVectors(track.mid, track.end, smoothstep((t-0.5)*2));
}

/* -----------------------
   Animation loop
   ----------------------- */
let last = performance.now();
function animate(now){
  requestAnimationFrame(animate);
  const dt = (now - last) / 1000; last = now;

  // eased progress
  const e = smoothstep(state.t);

  // camera position driven by scroll path (sampleTrack returns target)
  const camBase = sampleTrack(state.t);
  // we lerp gradually so motion is smooth even when user scroll is jerky
  camera.position.lerp(camBase, 0.08);

  // lookAt interpolation: hero-look -> center look as we enter
  const heroLook = new THREE.Vector3(1000, -20, 0);
  const cineLook = new THREE.Vector3(0, -20, 0);
  const look = new THREE.Vector3().lerpVectors(heroLook, cineLook, e);
  camera.lookAt(look);

  // Idle rotation while hero (subtle). We want NO automatic heavy rotation at hero:
  // Keep it very gentle always; when cinematic, allow slight rotation but slower than previous.
  // rotMix = how much hero idle should apply (1 at hero, 0 at cine)
  const rotMix = 1 - e;
  // hero idle: tiny movements
  room.rotation.y += 0.0015 * rotMix; // very slow
  room.rotation.x += 0.0008 * rotMix;

// inside cinematic: ultra slow, subtle rotation (Ultra Slow Tron Mode)
if (e > 0.01) {
    // Yaw: rotación principal super lenta
    room.rotation.y += 0.00065 * dt * 60;

    // Wobble X: movimiento casi imperceptible, muy suave
    room.rotation.x += 0.00018 * Math.sin(now * 0.00045);

    // Roll Z: micro movimiento, SUPER sutil (casi fijo)
    room.rotation.z = 0.00035 * Math.sin(now * 0.00035);
} else {
    room.rotation.z = 0;
}



  // room scale interpolation (feeling of entering)
  /* Ultra Cinematic Growth */
let baseScale = 0.85;       // tamaño en hero (igual al tuyo)
let maxScale  = 1.35;       // tamaño cuando estás dentro del cubo
let growth    = baseScale + (maxScale - baseScale) * e;

room.scale.set(growth, growth, growth);


  // bloom ramp a bit with cinematic
  bloom.strength = 0.7 + e * 0.9;

  // render
  composer.render();
}
requestAnimationFrame(animate);

/* debug helper */
window.__itb = { room, camera, track, state };

</script>
</body>
</html>
